HTTP缓存的来龙去脉

1.原始模型：浏览器请求数据，服务器响应数据。再次请求，再次返回。
缺点：浪费用户流量、消耗服务器资源，需要下载渲染影响用户体验。

2.有缓存但没有机制：客户端第一次请求数据，以后不再请求。
缺点：服务器上的文件更新了，浏览器也感知不到，拿不到最新的数据。

3.Expries机制：服务器告知浏览器文件的过期时间。这样过期就请求新数据，不过期就不请求。
缺点：请求后，服务器不管文件更没更新，都要读取文件返回给浏览器。

4.Last-modified与If-modified-Since: 请求数据后服务器返回Last-modified以及Expries过期时间，
当缓存过期后浏览器带上If-modeified-Since请求数据，如果修改时间一致，就返回304，不一致就返回新文件200，重新设置Last-modified和Expries。
缺点：Expries过期不稳定，浏览器的可以随意修改时间，Last-modified过期只能精确到秒。

5.引入Cache-Contorl，可以详细的控制缓存机制。资源是否可以被代理缓存，是否可以被缓存，过期时间，缓存新鲜期等等。

6.If-None-Match与Etag：Etag是文件的唯一ID。浏览器再次请求带If-modified-since和If-None-Math:Etag值, 服务器对比Etag值一致则304，不一致返回新文件200。
缺点：缓存过期前浏览器无法主动得知服务器上的文件资源变化了。

7.不缓存html文件，每次请求都能拿到最新的html资源，当其他资源内容更新的时候，只需修改其中的版本号。版本号相同就直接用缓存的，不同则申请新的资源。

强缓存：对于常规请求，只要存在该资源的缓存，且cache-control:max-age或expires没有过期，就命中强缓存，浏览器便不会向服务器发送请求，而是直接读取缓存。否则缓存失败，向服务器请求最新资源。
协商缓存：如果缓存过期了，就需要向服务器发起请求验证资源是否有更新，可以通过If-None-Match加Etag验证资源。资源没有修改，就返回304状态码，有修改则返回新文件和200状态码。
先判断强缓存，强缓存判断失败则判定协商缓存。强缓存返回200，协商缓存返回304/200。
